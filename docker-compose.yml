# ==========================================================================
# Unified Docker Compose — Paayo Nepal
#
# Profiles:
#   local  — Local development: only PostgreSQL + Redis (ports exposed)
#            Backend and frontend run natively on the host.
#   dev    — Development: full stack with frontend in dev mode (hot reload).
#            Uses `bun run dev` for Next.js with source code mounted.
#   prod   — Production: full stack with Nginx, Rust backend, Next.js frontend,
#            PostgreSQL, and Redis behind a reverse proxy.
#
# Usage:
#   # Local development (postgres + redis only)
#   docker compose --profile local up -d
#
#   # Dev mode (full stack, frontend live mount + bun dev)
#   docker compose --profile dev up -d
#   docker compose --profile dev up -d --build backend   # rebuild backend only
#
#   # Production (full stack)
#   docker compose --profile prod up -d
#   docker compose --profile prod up -d --build   # rebuild images
#   docker compose --profile prod logs -f          # tail all logs
#   docker compose --profile prod down             # stop everything
#
# Architecture (prod profile):
#   Browser → Nginx (port 80/443)
#     ├── /api/auth/*     → Next.js  (BetterAuth)
#     ├── /api/notifications/* → Next.js  (SSE + notifications proxy)
#     ├── /api/*          → Rust backend (all other data API)
#     ├── /uploads/*      → Rust backend (static files)
#     └── /*              → Next.js (SSR pages)
#
# Security (V-014):
#   PostgreSQL and Redis ports are ONLY exposed to the host in the `local`
#   profile. In `prod`, they communicate exclusively over the internal Docker
#   network (`paayo_net`). This prevents accidental exposure of database
#   ports on production hosts.
# ==========================================================================

# --------------------------------------------------------------------------
# YAML Anchors — shared configuration fragments to avoid duplication
# between local and prod service definitions.
# --------------------------------------------------------------------------

x-postgres-common: &postgres-common
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
        POSTGRES_DB: ${DATABASE_NAME:-tourism}
        POSTGRES_USER: ${DATABASE_USER:-tourism}
        POSTGRES_PASSWORD: ${DATABASE_PASSWORD:-tourism_dev_password}
    volumes:
        - postgres_data:/var/lib/postgresql/data
    healthcheck:
        test:
            [
                "CMD-SHELL",
                "pg_isready -U ${DATABASE_USER:-tourism} -d ${DATABASE_NAME:-tourism}",
            ]
        interval: 10s
        timeout: 5s
        retries: 5
        start_period: 10s
    networks:
        - paayo_net

x-redis-common: &redis-common
    image: redis:7.4-alpine
    restart: unless-stopped
    command: >
        redis-server
        --appendonly yes
        --requirepass ${REDIS_PASSWORD:-redis_dev_password}
        --maxmemory ${REDIS_MAX_MEMORY:-256mb}
        --maxmemory-policy allkeys-lru
    volumes:
        - redis_data:/data
    healthcheck:
        test:
            [
                "CMD",
                "redis-cli",
                "-a",
                "${REDIS_PASSWORD:-redis_dev_password}",
                "ping",
            ]
        interval: 10s
        timeout: 5s
        retries: 5
    networks:
        - paayo_net

x-frontend-env: &frontend-env
    NODE_ENV: ${NODE_ENV:-production}
    DOCKER_ENV: "true"
    NEXT_PUBLIC_APP_URL: ${NEXT_PUBLIC_APP_URL:-http://localhost}
    DATABASE_URL: postgresql://${DATABASE_USER:-tourism}:${DATABASE_PASSWORD:-tourism_dev_password}@postgres:5432/${DATABASE_NAME:-tourism}
    BACKEND_API_URL: http://backend:8080/api
    BACKEND_URL: http://backend:8080
    REDIS_URL: redis://:${REDIS_PASSWORD:-redis_dev_password}@redis:6379
    REDIS_HOST: redis
    REDIS_PORT: "6379"
    REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_dev_password}
    BETTER_AUTH_SECRET: ${BETTER_AUTH_SECRET:-dev-secret-change-in-production}
    PASSKEY_RP_ID: ${PASSKEY_RP_ID:-localhost}
    GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID:-}
    GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET:-}

x-backend-common: &backend-common
    build:
        context: ./tour_backend
        dockerfile: Dockerfile
    restart: unless-stopped
    environment:
        - HOST=0.0.0.0
        - PORT=8080
        - DATABASE_URL=postgresql://${DATABASE_USER:-tourism}:${DATABASE_PASSWORD:-tourism_dev_password}@postgres:5432/${DATABASE_NAME:-tourism}
        - DATABASE_MAX_CONNECTIONS=${DATABASE_MAX_CONNECTIONS:-20}
        - DATABASE_MIN_CONNECTIONS=${DATABASE_MIN_CONNECTIONS:-5}
        - REDIS_URL=redis://:${REDIS_PASSWORD:-redis_dev_password}@redis:6379
        - UPLOAD_PATH=/app/uploads
        - MAX_UPLOAD_SIZE=${MAX_UPLOAD_SIZE:-52428800}
        - MAX_IMAGE_WIDTH=${MAX_IMAGE_WIDTH:-1920}
        - THUMBNAIL_WIDTH=${THUMBNAIL_WIDTH:-400}
        - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-http://localhost,http://nginx}
        - ADMIN_EMAIL=${ADMIN_EMAIL:-admin@gmail.com}
        - ADMIN_PASSWORD=${ADMIN_PASSWORD:-admin@#12}
        - ADMIN_NAME=${ADMIN_NAME:-Admin}
        - VIEWER_HASH_SALT=${VIEWER_HASH_SALT:-change-this-in-production}
        # Use a backend-specific log filter so host/global RUST_LOG does not
        # accidentally flood dev logs with trace/debug noise.
        - RUST_LOG=${BACKEND_LOG_FILTER:-tour_backend=info,tower_http=warn,sqlx=warn}
    volumes:
        - upload_data:/app/uploads
    expose:
        - "8080"
    networks:
        - paayo_net
    healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8080/api/live"]
        interval: 60s
        timeout: 5s
        retries: 5
        start_period: 10s

services:
    # -----------------------------------------------------------------------
    # PostgreSQL — Local development (ports exposed to host)
    #
    # Only active in the `local` profile. Exposes port 5432 so the developer
    # can connect from the host (e.g. via psql, pgAdmin, or the natively-
    # running backend).
    # -----------------------------------------------------------------------
    postgres-local:
        <<: *postgres-common
        profiles: ["local"]
        ports:
            - "${POSTGRES_PORT:-5432}:5432"

    # -----------------------------------------------------------------------
    # PostgreSQL — Production (internal only)
    #
    # Only active in the `prod` profile. The port is NOT exposed to the host;
    # only containers on the `paayo_net` network can reach it. This closes
    # the V-014 finding.
    # -----------------------------------------------------------------------
    postgres:
        <<: *postgres-common
        profiles: ["prod", "dev"]
        expose:
            - "5432"

    # -----------------------------------------------------------------------
    # Redis — Local development (ports exposed to host)
    # -----------------------------------------------------------------------
    redis-local:
        <<: *redis-common
        profiles: ["local"]
        ports:
            - "${REDIS_PORT:-6379}:6379"

    # -----------------------------------------------------------------------
    # Redis — Production (internal only)
    # -----------------------------------------------------------------------
    redis:
        <<: *redis-common
        profiles: ["prod", "dev"]
        expose:
            - "6379"

    # -----------------------------------------------------------------------
    # Nginx — Reverse proxy & TLS termination (prod + dev)
    # -----------------------------------------------------------------------
    nginx:
        image: nginx:1.27-alpine
        restart: unless-stopped
        profiles: ["prod", "dev"]
        ports:
            - "${NGINX_HTTP_PORT:-80}:80"
            - "${NGINX_HTTPS_PORT:-443}:443"
        volumes:
            - ./docker/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
            # Uncomment for TLS:
            # - ./docker/nginx/certs:/etc/nginx/certs:ro
            - nginx_cache:/var/cache/nginx
        depends_on:
            backend:
                condition: service_healthy
        networks:
            - paayo_net
        healthcheck:
            test:
                [
                    "CMD",
                    "wget",
                    "--no-verbose",
                    "--tries=1",
                    "--spider",
                    "http://127.0.0.1/nginx-health",
                ]
            interval: 15s
            timeout: 5s
            retries: 3

    # -----------------------------------------------------------------------
    # Rust Backend — Data API, file uploads, engagement (prod + dev)
    # -----------------------------------------------------------------------
    backend:
        <<: *backend-common
        profiles: ["prod", "dev"]
        depends_on:
            postgres:
                condition: service_healthy
            redis:
                condition: service_healthy

    # -----------------------------------------------------------------------
    # Next.js Frontend — Production build (prod only)
    # -----------------------------------------------------------------------
    frontend:
        build:
            context: ./tour_frontend
            dockerfile: Dockerfile
        restart: unless-stopped
        profiles: ["prod"]
        environment:
            <<: *frontend-env
            NODE_ENV: production
        expose:
            - "3000"
        depends_on:
            postgres:
                condition: service_healthy
            redis:
                condition: service_healthy
        networks:
            - paayo_net

    # -----------------------------------------------------------------------
    # Next.js Frontend — Dev mode with live source mount (dev only)
    #
    # No image build for frontend in dev profile.
    # Container runs directly from mounted host source:
    #   ./tour_frontend -> /app
    # This gives immediate code updates and quick `docker compose restart
    # frontend-dev` recovery when the dev server hangs.
    # -----------------------------------------------------------------------
    frontend-dev:
        image: oven/bun:1.2
        restart: unless-stopped
        profiles: ["dev"]
        working_dir: /app
        command: >
            sh -lc "bun install && bun run dev --hostname 0.0.0.0 --port 3000"
        environment:
            <<: *frontend-env
            NODE_ENV: development
            NEXT_TELEMETRY_DISABLED: "1"
            WATCHPACK_POLLING: "true"
        volumes:
            - ./tour_frontend:/app
            - frontend_node_modules:/app/node_modules
            - frontend_bun_cache:/root/.bun/install/cache
        expose:
            - "3000"
        depends_on:
            postgres:
                condition: service_healthy
            redis:
                condition: service_healthy
        networks:
            paayo_net:
                aliases:
                    - frontend

# -------------------------------------------------------------------------
# Volumes
# -------------------------------------------------------------------------
volumes:
    postgres_data:
        driver: local
    redis_data:
        driver: local
    upload_data:
        driver: local
    nginx_cache:
        driver: local
    frontend_node_modules:
        driver: local
    frontend_bun_cache:
        driver: local

# -------------------------------------------------------------------------
# Network
# -------------------------------------------------------------------------
networks:
    paayo_net:
        driver: bridge
