import { baseApi, buildQueryString } from "./baseApi";
import type { SearchResponse } from "@/lib/api-client";

// ---------------------------------------------------------------------------
// Query parameter types
// ---------------------------------------------------------------------------

export interface SearchParams {
  query: string;
  limit?: number;
  type?: string;
}

// ---------------------------------------------------------------------------
// Search API slice — injected into the base API
//
// Provides site-wide content search across all content types (posts, events,
// attractions, activities, regions, hotels, videos, photo features).
//
// The backend performs full-text search across titles, descriptions, and
// content fields, returning results ranked by relevance. Each result
// includes a `result_type` field indicating what kind of content it is,
// and a `url` field with the canonical frontend path for the result.
//
// Endpoint:
//   GET /search?q=<query>&limit=<limit>&type=<type>
//
// The `type` parameter is optional and filters results to a specific
// content type (e.g., "post", "event", "attraction", "hotel", "video",
// "photo", "region", "activity").
//
// Search is public — no authentication required.
// ---------------------------------------------------------------------------

export const searchApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    // ─── Queries ──────────────────────────────────────────────────────

    /**
     * Search for content across the entire platform.
     *
     * Returns a `SearchResponse` containing:
     *   - `query`:   the original search string (echoed back)
     *   - `total`:   total number of matching results
     *   - `results`: array of `SearchResult` objects, each with:
     *       - `id`:          content item UUID
     *       - `title`:       item title
     *       - `slug`:        URL slug
     *       - `excerpt`:     short text excerpt (may contain highlights)
     *       - `cover_image`: thumbnail / cover image URL (nullable)
     *       - `result_type`: content type ("post", "event", "attraction", etc.)
     *       - `url`:         canonical frontend URL for the result
     *
     * Cache strategy:
     *   Search results are cached by query + params for a short duration
     *   (30 seconds). This prevents redundant requests when the user
     *   navigates back to a search results page they already visited,
     *   while keeping results reasonably fresh.
     *
     *   The `Search` tag is invalidated broadly — any content mutation
     *   does NOT invalidate search results, because search re-indexing
     *   on the backend is asynchronous. Users can manually re-search
     *   to get fresh results.
     *
     * Cache tags:
     *   - { type: 'Search', id: '<query>-<type>-<limit>' }
     *
     * Usage:
     *   const { data, isLoading, isFetching } = useSearchQuery({
     *     query: "trekking in nepal",
     *     limit: 20,
     *   });
     *
     *   // Skip the query until the user has typed at least 2 characters
     *   const { data } = useSearchQuery(
     *     { query: searchInput },
     *     { skip: searchInput.length < 2 },
     *   );
     *
     *   // Access results
     *   data?.results.forEach((result) => {
     *     console.log(result.title, result.result_type, result.url);
     *   });
     */
    search: builder.query<SearchResponse, SearchParams>({
      query: ({ query, limit, type }) =>
        `/search${buildQueryString({
          q: query,
          limit,
          type,
        })}`,
      providesTags: (_result, _error, { query, type, limit }) => [
        {
          type: "Search",
          id: `${query}-${type ?? "all"}-${limit ?? "default"}`,
        },
      ],
      keepUnusedDataFor: 30,
    }),

    /**
     * Search with debounce-friendly usage pattern.
     *
     * This is the same endpoint as `search` but exposed as a lazy query
     * for use cases where you want to trigger the search manually
     * (e.g., on form submit) rather than reactively (on every keystroke).
     *
     * For reactive/autocomplete search, use `useSearchQuery` with the
     * `skip` option and debounce the input value in your component state.
     *
     * Usage:
     *   const [triggerSearch, { data, isLoading }] = useLazySearchQuery();
     *
     *   const handleSubmit = async (query: string) => {
     *     const result = await triggerSearch({ query, limit: 20 }).unwrap();
     *     console.log(`Found ${result.total} results`);
     *   };
     */
    // The lazy version is auto-generated by RTK Query when you export
    // `useLazySearchQuery` below — no additional endpoint needed.
  }),

  overrideExisting: false,
});

// ---------------------------------------------------------------------------
// Auto-generated hooks
//
// Usage:
//   import {
//     useSearchQuery,
//     useLazySearchQuery,
//   } from "@/lib/store/api/searchApi";
//
//   // ── Reactive search (autocomplete / live search) ──
//   // Automatically fetches when `searchQuery` changes.
//   // Use `skip` to prevent fetching until the user has typed enough.
//   //
//   //   const [searchQuery, setSearchQuery] = useState("");
//   //   const [debouncedQuery] = useDebounce(searchQuery, 300);
//   //
//   //   const { data, isLoading, isFetching } = useSearchQuery(
//   //     { query: debouncedQuery, limit: 10 },
//   //     { skip: debouncedQuery.length < 2 },
//   //   );
//
//   // ── Manual search (form submit) ──
//   // Triggered explicitly, useful for search pages with a submit button.
//   //
//   //   const [triggerSearch, { data, isLoading }] = useLazySearchQuery();
//   //
//   //   const handleSubmit = (e: FormEvent) => {
//   //     e.preventDefault();
//   //     triggerSearch({ query: inputValue, limit: 20 });
//   //   };
//
//   // ── Filtered search (by content type) ──
//   // Show only results of a specific type.
//   //
//   //   const { data } = useSearchQuery({
//   //     query: "kathmandu",
//   //     type: "attraction",
//   //     limit: 10,
//   //   });
//
//   // ── Access results ──
//   //   if (data) {
//   //     console.log(`Found ${data.total} results for "${data.query}"`);
//   //     data.results.forEach((result) => {
//   //       console.log(result.title, result.result_type, result.url);
//   //     });
//   //   }
// ---------------------------------------------------------------------------

export const {
  useSearchQuery,
  useLazySearchQuery,
} = searchApi;
